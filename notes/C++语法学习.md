# C++语法系统学习

### 第一章 绪论 省略

### 第二章 C++程序的组成部分

1.程序入口

int main(int argc, char* argv[])

argc是参数的数量

argv是命令行的参数数组，argv[0]默认是函数名字，例如./test



2.namespace命名空间

namespace的作用是在大型项目中，多人协同工作中，防止出现命名冲突。

例如程序员A和B，写了相同的函数或者类，程序不知道调用哪个，而实现声明命名空间即可避免这个问题。



3.流stream

流可以抽象理解为数据传输通道

流的来源和去向可以是内存，文件，控制台，网络

后续进行进一步学习





### 第三章 使用变量和常量

1.常量变量

变量，作用域内有效

常量，程序运行过程中不可改变

const定义的常量

const和constexpr都可以定义常量

但是const定义的常量可以在编译时不赋值，在运行时赋值一次。也就是说const定义的常量在运行时只可以赋值一次，不可修改，可以读取多次。

constexpr定义的常量必须在编译时就确定值，不可以在运行时赋值。相比于const更严格。



2.内存

C++程序有五个主要的存储区

代码区，数据区，BSS区，堆，栈



代码区：存放程序的机器指令

数据区：存放已经初始化的全局变量和静态变量

BSS区：存放未初始化或者初始化为0的全局变量和静态变量

堆：用来动态分配的内存

栈：存放函数的局部变量、函数参数、返回地址



3.static定义变量和函数

static定义的变量存放在数据区或者BSS区

在函数内部定义静态变量会使得该变量只会初始化一次(程序执行到这里的时候)，并且该变量的生命周期是从程序开始到程序结束，并且限制变量的适用范围只在该函数

static定义的全局变量会使得该变量无法被此项目中的其他文件访问，只能在该文件下被访问。



static定义的函数会使得该函数只能在该文件中被访问，在此项目中的其他文件无法被访问

static定义的类成员函数不会仅限该文件(public)，而且不需要this指针，可以在没有对象的情况下访问。
### 第四章 数组和字符串

1.

char定义的数组默认最后一个元素是\0，定义char数组时，后面要加上\0，中间不能加，否则会导致垃圾内存的出现。

总之建议用string，不建议用C语言风格的strlen，strcpy等函数。



### 第五章 使用表达式、语句和运算符

略



### 第六章 控制程序流程

略



### 第七章 使用函数组织代码

1.内联函数

使用inline定义函数，通常是建议编译器在编译过程中直接在调用的地方展开函数，一般函数较为简单且非递归，为了减少调用和返回，从而提高性能。



### 第八章 指针和引用

1.

```C++
int x=5;//整数
int *p=&x;//一级指针
int **q=&p;//二级指针
```

2.

内存泄漏，new的内存没有delete。或者说malloc的内存没有free

3.

malloc/free    new/delete

malloc和free是C语言，返回的指针默认是void*，实际使用需要强制类型转换

new和delete是C++语言，当动态分配的内存存放的是对象时，释放内存时会自动调用析构函数，free不会自动调用

malloc分配失败返回NULL，new分配失败返回std::bad_alloc异常

4.

const和指针

```C++
int const* /const int*  //不可以通过指针修改内容

int *const            //指向的位置不可变

const int *const      //指向的位置不可变，也无法通过指针修改内容
```



### 第九章 类和对象

1.
复制构造函数，浅拷贝/深拷贝

如果类的成员有动态分配内存的成员，必须单独写复制构造函数，为了防止出现浅拷贝的问题。如果使用默认的复制构造函数，会出现新对象中动态分配内存的指针指向原对象中的指针指向的内存，而当其中一个对象调用析构函数释放内存之后，另一个对象中的指针也无法使用，导致程序不安全。

所以针对这种情况需要单独写复制构造函数，将动态分配内存的成员进行复制，在新对象中也动态分配内存并将其中的内容也复制。

浅拷贝就是只复制值，包括指针也是。

深拷贝不仅复制值，指针会复制内存，这样两个指针指向不同的内存，互不影响。

复制构造函数的参数必须按照引用传递，而且要用const

2.
单例模式

指的是某些类只需要一个对象，例如日志系统

实现方式：

构造函数和静态对象放在private中

复制构造函数在private中delete

在public中写返回静态对象的函数

饿汉：类外声明

懒汉：类外声明为nullptr

懒汉模式是将对象存放在堆中，程序不会自动调用析构函数，需要显式调用，在写代码的时候调用析构函数，所以析构函数也需要写在public中。

饿汉模式是将对象存放在静态存储区中，可以将析构函数写在private中，即使这样，程序也会自动调用析构函数。

如果在栈中声明对象，会自动调用析构函数，析构函数必须是public。

如果只想在堆中声明对象，需要自己显式调用析构函数或者自己写一个销毁函数。因为堆的使用是由程序员自己决定的。

3.
防止隐式转换，explicit，（单参数构造函数）

用explicit可以使得程序只能显式调用构造函数

```C++
class A {
public:
    explicit A(int x) { std::cout << "A构造函数: " << x << std::endl; }
};

void func(A a) {
    std::cout << "func called\n";
}

int main() {
    // func(10);  // ❌ 错误，不能隐式转换
    func(A(10));  // ✅ 显式调用
}

```

4.
友元

声明以后可以访问private成员

```C++
class A{
    friend void submit();//外部函数
    friend class B;//类
    friend C::show();//类成员函数
};
```

5.
union

共用体，结构的长度是最大成员的长度，同一时刻只有一个成员有效，只能访问一个成员



### 第十章 实现继承

1.
继承方式与访问限制

|继承方式|基类 public|基类 protected|基类 private|
|-|-|-|-|
|**public**|public|protected|private|
|**protected**|protected|protected|private|
|**private**|private|private|private|


public保证派生类内部可以访问，外部可以访问

protect保证派生类内部可以访问，外部不可以访问

private保证派生类内部不可以访问，外部也不可以访问

2.
子类与基类同名函数（重载）

有同名函数时

子类对象默认访问子类函数，要想访问基类同名函数必须加上作用域限定符

没有同名函数时

只要基类函数是public，子类对象就可以直接访问。

3.
子类对象的初始化和析构

子类对象会先调用基类的构造函数，再调用子类的构造函数，默认从上到下

子类对象会先调用子类的析构函数，再调用基类的析构函数，默认从下到上

每个子类对象声明之后都会默认声明基类对象

4.
切除

```C++
//基类base，子类derive
derive objder;
base objbase=objder;//显式
base objbase(objder);//隐式传参
```

这样的结果是基类对象只会复制基类，相当于新对象只保留原来的子类对象中的基类部分。

5.
final

禁止继承
